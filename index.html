<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ocean Waves</title>
  <style>
    * { margin: 0; padding: 0; }
    html, body {
      overflow: hidden;
      cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g fill="white" opacity="0.95"><path d="M12 0.6 L13.1 11.6 L10.9 11.6 Z"/><path d="M12 0.6 L13.1 11.6 L10.9 11.6 Z" transform="rotate(180 12 12)"/><path d="M23.2 12 L12.4 12.9 L12.4 11.1 Z"/><path d="M23.2 12 L12.4 12.9 L12.4 11.1 Z" transform="rotate(180 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(45 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(135 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(225 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(315 12 12)"/><path d="M12 9.4 L13.1 12 L12 14.6 L10.9 12 Z" opacity="0.85"/><circle cx="12" cy="12" r="0.6" opacity="0.85"/></g></svg>') 12 12, auto;
    }
    * { cursor: inherit; }
    canvas { display: block; width: 100vw; height: 100vh; image-rendering: auto; }
    #fps { position: fixed; top: 10px; left: 10px; color: white; font: 16px monospace; background: rgba(0,0,0,0.5); padding: 5px 10px; z-index: 100; display: none; }
    #fps.visible { display: block; }
    
    /* Logo styles */
    .main-logo {
      position: fixed;
      top: 60px;
      left: 60px;
      width: 300px;
      max-width: 65vw;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }
    
    .main-logo svg {
      width: 100%;
      height: auto;
    }
    
    @media (max-width: 800px) {
      .main-logo {
        top: 50px;
        right: 50px;
        width: 210px;
        max-width: calc(65vw * 0.7);
      }
    }
  </style>
</head>
<body>
  <div id="fps">FPS: --</div>
  
  <!-- Earendil Logo -->
  <div class="main-logo" id="logo">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 324.14 245.98">
      <defs>
        <style>.st0 { fill: #fff; }</style>
      </defs>
      <g>
        <path class="st0" d="M28.2,224.5v-27.64h19.92v6.05h-12.41v4.75h11.39v6.04h-11.39v4.75h12.36v6.05h-19.87Z"/>
        <path class="st0" d="M70.42,224.5h-8.1l9.12-27.64h10.26l9.12,27.64h-8.1l-6.04-20.03h-.22l-6.05,20.03h0ZM68.91,213.6h15.22v5.61h-15.22v-5.61Z"/>
        <path class="st0" d="M104.87,224.5v-27.64h11.93c2.05,0,3.85.37,5.38,1.12,1.54.75,2.73,1.82,3.59,3.23s1.28,3.09,1.28,5.05-.44,3.65-1.32,5.01-2.11,2.38-3.68,3.08c-1.58.69-3.42,1.04-5.53,1.04h-7.12v-5.83h5.61c.88,0,1.63-.11,2.26-.33.62-.22,1.11-.57,1.44-1.06.34-.49.51-1.12.51-1.9s-.17-1.44-.51-1.94-.82-.87-1.44-1.11c-.63-.24-1.38-.36-2.26-.36h-2.64v21.64h-7.5ZM121.06,211.82l6.91,12.68h-8.15l-6.75-12.68h7.99Z"/>
        <path class="st0" d="M141.64,224.5v-27.64h19.92v6.05h-12.41v4.75h11.39v6.04h-11.39v4.75h12.36v6.05h-19.87Z"/>
        <path class="st0" d="M200.59,196.87v27.64h-6.26l-9.99-14.52h-.16v14.52h-7.5v-27.64h6.37l9.82,14.47h.22v-14.47h7.5Z"/>
        <path class="st0" d="M226.19,224.5h-10.63v-27.64h10.53c2.84,0,5.3.55,7.38,1.65,2.07,1.1,3.67,2.69,4.8,4.75s1.69,4.54,1.69,7.42-.56,5.35-1.69,7.42c-1.12,2.06-2.72,3.65-4.78,4.75-2.06,1.1-4.49,1.65-7.3,1.65ZM223.06,218.13h2.86c1.37,0,2.54-.22,3.5-.66.97-.44,1.71-1.2,2.21-2.28.51-1.08.76-2.58.76-4.51s-.26-3.43-.78-4.51-1.27-1.84-2.27-2.28c-.99-.44-2.21-.66-3.65-.66h-2.64v14.9h.01Z"/>
        <path class="st0" d="M262.31,196.87v27.64h-7.5v-27.64h7.5Z"/>
        <path class="st0" d="M277.27,224.5v-27.64h7.5v21.59h11.17v6.05h-18.68.01Z"/>
      </g>
      <path class="st0" d="M202.89,123.89c.4,29.74-40.27,26.97-40.8,48.11h-.05c-.52-21.14-41.19-18.38-40.8-48.11,27.99,0,40.09-46.29,40.82-101.27.74,54.98,12.83,101.27,40.82,101.27h0Z"/>
    </svg>
  </div>
  
  <canvas id="canvas"></canvas>
  <script>
    // Show FPS counter only if ?fps is in URL
    const fpsDisplay = document.getElementById('fps');
    if (new URLSearchParams(window.location.search).has('fps')) {
      fpsDisplay.classList.add('visible');
    }

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');

    const vertexShaderSource = `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    // Dither post-process shaders
    const ditherVertexShaderSource = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;

    // Film grain post-process shader (MIT licensed, based on martinsh/devlog-film-grain)
    const ditherFragmentShaderSource = `
      precision highp float;
      uniform sampler2D u_image;
      uniform vec2 u_resolution;
      uniform float u_time;
      varying vec2 v_texCoord;

      #define INTENSITY 0.18
      #define SPEED 2.0
      #define MEAN 0.0
      #define VARIANCE 0.5

      float gaussian(float z, float u, float o) {
        return (1.0 / (o * sqrt(2.0 * 3.1415))) * exp(-(((z - u) * (z - u)) / (2.0 * (o * o))));
      }

      void main() {
        vec4 color = texture2D(u_image, v_texCoord);
        
        // Convert to grayscale
        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
        
        // Film grain noise
        float t = u_time * SPEED;
        vec2 uv = gl_FragCoord.xy / u_resolution;
        float seed = dot(uv, vec2(12.9898, 78.233));
        float noise = fract(sin(seed) * 43758.5453 + t);
        noise = gaussian(noise, MEAN, VARIANCE * VARIANCE);
        
        // Apply grain (addition blend mode)
        vec3 grain = vec3(noise) * (1.0 - vec3(gray));
        gray = gray + grain.r * INTENSITY;
        gray = clamp(gray, 0.0, 1.0);
        
        // Map to color palette
        vec3 dark = vec3(0.235);   // #3c3c3c
        vec3 light = vec3(0.836);  // #d5d5d5
        gl_FragColor = vec4(mix(dark, light, gray), 1.0);
      }
    `;

    const fragmentShaderSource = `
      precision highp float;
      uniform vec2 iResolution;
      uniform float iTime;

      // afl_ext 2017-2024
      // MIT License

      #define DRAG_MULT 0.38
      #define WATER_DEPTH 1.0
      #define CAMERA_HEIGHT 1.5
      #define ITERATIONS_RAYMARCH 8
      #define ITERATIONS_NORMAL 16

      vec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {
        float x = dot(direction, position) * frequency + timeshift;
        float wave = exp(sin(x) - 1.0);
        float dx = wave * cos(x);
        return vec2(wave, -dx);
      }

      float getwaves(vec2 position, int iterations) {
        float wavePhaseShift = length(position) * 0.1;
        float iter = 0.0;
        float frequency = 1.0;
        float timeMultiplier = 2.0;
        float weight = 1.0;
        float sumOfValues = 0.0;
        float sumOfWeights = 0.0;
        for(int i=0; i < 16; i++) {
          if(i >= iterations) break;
          vec2 p = vec2(sin(iter), cos(iter));
          vec2 res = wavedx(position, p, frequency, iTime * timeMultiplier + wavePhaseShift);
          position += p * res.y * weight * DRAG_MULT;
          sumOfValues += res.x * weight;
          sumOfWeights += weight;
          weight = mix(weight, 0.0, 0.2);
          frequency *= 1.18;
          timeMultiplier *= 1.07;
          iter += 1232.399963;
        }
        float baseWaves = sumOfValues / sumOfWeights;

        vec2 swellDir = normalize(vec2(0.25, -1.0));
        float swellPhase = dot(position, swellDir) * 0.18 - iTime * 0.08;
        float swell = 0.5 + 0.5 * sin(swellPhase);
        swell = pow(swell, 2.0);
        vec2 cameraPos = vec2(iTime * 0.2, 1.0);
        float swellFade = smoothstep(28.0, 4.0, length(position - cameraPos));

        return baseWaves + swell * swellFade * 0.35;
      }

      float raymarchwater(vec3 camera, vec3 start, vec3 end, float depth) {
        vec3 pos = start;
        vec3 dir = normalize(end - start);
        for(int i=0; i < 32; i++) {
          float height = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;
          if(height + 0.01 > pos.y) {
            return distance(pos, camera);
          }
          pos += dir * (pos.y - height);
        }
        return distance(start, camera);
      }

      vec3 normal(vec2 pos, float e, float depth) {
        vec2 ex = vec2(e, 0);
        float H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;
        vec3 a = vec3(pos.x, H, pos.y);
        return normalize(
          cross(
            a - vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y), 
            a - vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e)
          )
        );
      }

      mat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        return mat3(
          oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 
          oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 
          oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c
        );
      }

      vec3 getRay(vec2 fragCoord) {
        vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);
        vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));
        // Fixed camera angle (no mouse movement) - tilted down to show only water
        return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 0.0) 
          * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.05)
          * proj;
      }

      float intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { 
        return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); 
      }

      vec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir) {
        float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);
        float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);
        float raysundt = pow(abs(dot(sundir, raydir)), 2.0);
        float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);
        float mymie = sundt * special_trick * 0.2;
        vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);
        vec3 bluesky= vec3(12.0, 12.0, 13.0) / 22.4 * suncolor;
        vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(12.0, 12.0, 13.0) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));
        bluesky2 *= special_trick * (0.24 + raysundt * 0.24);
        return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0));
      } 

      vec3 getSunDirection() {
        // Static sun position (no movement)
        return normalize(vec3(-0.0773502691896258, 0.6, 0.5773502691896258));
      }

      vec3 getAtmosphere(vec3 dir) {
         return extra_cheap_atmosphere(dir, getSunDirection()) * 0.5;
      }

      float getSun(vec3 dir) { 
        // No visible sun disc
        return 0.0;
      }

      vec3 aces_tonemap(vec3 color) {  
        mat3 m1 = mat3(
          0.59719, 0.07600, 0.02840,
          0.35458, 0.90834, 0.13383,
          0.04823, 0.01566, 0.83777
        );
        mat3 m2 = mat3(
          1.60475, -0.10208, -0.00327,
          -0.53108,  1.10813, -0.07276,
          -0.07367, -0.00605,  1.07602
        );
        vec3 v = m1 * color;  
        vec3 a = v * (v + 0.0245786) - 0.000090537;
        vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
        return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  
      }

      void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        vec3 ray = getRay(fragCoord);
        if(ray.y >= 0.0) {
          vec3 C = getAtmosphere(ray);
          fragColor = vec4(aces_tonemap(C * 2.0), 1.0);   
          return;
        }

        vec3 waterPlaneHigh = vec3(0.0, 0.0, 0.0);
        vec3 waterPlaneLow = vec3(0.0, -WATER_DEPTH, 0.0);
        vec3 origin = vec3(iTime * 0.2, CAMERA_HEIGHT, 1);

        float highPlaneHit = intersectPlane(origin, ray, waterPlaneHigh, vec3(0.0, 1.0, 0.0));
        float lowPlaneHit = intersectPlane(origin, ray, waterPlaneLow, vec3(0.0, 1.0, 0.0));
        vec3 highHitPos = origin + ray * highPlaneHit;
        vec3 lowHitPos = origin + ray * lowPlaneHit;

        float dist = raymarchwater(origin, highHitPos, lowHitPos, WATER_DEPTH);
        vec3 waterHitPos = origin + ray * dist;

        vec3 N = normal(waterHitPos.xz, 0.01, WATER_DEPTH);
        N = mix(N, vec3(0.0, 1.0, 0.0), 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));

        float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));

        vec3 R = normalize(reflect(ray, N));
        R.y = abs(R.y);
        
        vec3 reflection = getAtmosphere(R);
        vec3 scattering = vec3(0.08, 0.08, 0.09) * (0.2 + (waterHitPos.y + WATER_DEPTH) / WATER_DEPTH);

        vec3 C = fresnel * reflection + scattering;
        
        // Add distance fog
        vec3 fogColor = vec3(0.55, 0.55, 0.58);
        float fogAmount = 1.0 - exp(-dist * 0.02);
        C = mix(C, fogColor, fogAmount);
        
        fragColor = vec4(aces_tonemap(C * 2.0), 1.0);
      }

      void main() {
        mainImage(gl_FragColor, gl_FragCoord.xy);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    // Ocean wave program
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1, 1, -1, -1, 1,
      -1, 1, 1, -1, 1, 1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'position');
    const resolutionLocation = gl.getUniformLocation(program, 'iResolution');
    const timeLocation = gl.getUniformLocation(program, 'iTime');

    // Dither post-process program
    const ditherVertexShader = createShader(gl, gl.VERTEX_SHADER, ditherVertexShaderSource);
    const ditherFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, ditherFragmentShaderSource);
    const ditherProgram = createProgram(gl, ditherVertexShader, ditherFragmentShader);

    const ditherPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ditherPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    const ditherPositionLocation = gl.getAttribLocation(ditherProgram, 'a_position');

    const ditherTexCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ditherTexCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);
    const ditherTexCoordLocation = gl.getAttribLocation(ditherProgram, 'a_texCoord');

    const ditherResolutionLocation = gl.getUniformLocation(ditherProgram, 'u_resolution');
    const ditherImageLocation = gl.getUniformLocation(ditherProgram, 'u_image');
    const ditherTimeLocation = gl.getUniformLocation(ditherProgram, 'u_time');

    // Framebuffer for render-to-texture
    let framebuffer = null;
    let renderTexture = null;
    let fbWidth = 0;
    let fbHeight = 0;

    function setupFramebuffer(width, height) {
      if (framebuffer && fbWidth === width && fbHeight === height) return;
      
      if (framebuffer) {
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(renderTexture);
      }

      fbWidth = width;
      fbHeight = height;

      renderTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, renderTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function resize() {
      // Render at reduced resolution
      const scale = 0.4;
      canvas.width = window.innerWidth * window.devicePixelRatio * scale;
      canvas.height = window.innerHeight * window.devicePixelRatio * scale;
      setupFramebuffer(canvas.width, canvas.height);
    }

    window.addEventListener('resize', resize);
    resize();

    // FPS tracking
    let frameCount = 0;
    let lastFpsUpdate = 0;

    function render(time) {
      // Update FPS counter
      frameCount++;
      if (time - lastFpsUpdate >= 1000) {
        fpsDisplay.textContent = `FPS: ${frameCount} | ${canvas.width}x${canvas.height}`;
        frameCount = 0;
        lastFpsUpdate = time;
      }

      // Pass 1: Render ocean waves to framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.useProgram(program);
      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(timeLocation, time * 0.001);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Pass 2: Apply dither post-processing to screen
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.useProgram(ditherProgram);

      gl.enableVertexAttribArray(ditherPositionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherPositionBuffer);
      gl.vertexAttribPointer(ditherPositionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(ditherTexCoordLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherTexCoordBuffer);
      gl.vertexAttribPointer(ditherTexCoordLocation, 2, gl.FLOAT, false, 0, 0);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, renderTexture);
      gl.uniform1i(ditherImageLocation, 0);
      gl.uniform2f(ditherResolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(ditherTimeLocation, time * 0.001);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // Logo fade-in animation
    const logo = document.getElementById('logo');
    setTimeout(() => {
      logo.style.transition = 'opacity 5s ease';
      logo.style.opacity = '0.85';
    }, 600);
  </script>
</body>
</html>
