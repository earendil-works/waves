<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ocean Waves</title>
  <style>
    * { margin: 0; padding: 0; }
    html, body {
      overflow: hidden;
      cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g fill="white" opacity="0.95"><path d="M12 0.6 L13.1 11.6 L10.9 11.6 Z"/><path d="M12 0.6 L13.1 11.6 L10.9 11.6 Z" transform="rotate(180 12 12)"/><path d="M23.2 12 L12.4 12.9 L12.4 11.1 Z"/><path d="M23.2 12 L12.4 12.9 L12.4 11.1 Z" transform="rotate(180 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(45 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(135 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(225 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(315 12 12)"/><path d="M12 9.4 L13.1 12 L12 14.6 L10.9 12 Z" opacity="0.85"/><circle cx="12" cy="12" r="0.6" opacity="0.85"/></g></svg>') 12 12, auto;
    }
    * { cursor: inherit; }
    canvas { display: block; width: 100vw; height: 100vh; image-rendering: auto; }
    #fps { position: fixed; top: 10px; left: 10px; color: white; font: 16px monospace; background: rgba(0,0,0,0.5); padding: 5px 10px; z-index: 100; display: none; }
    #fps.visible { display: block; }
    
    /* Logo styles */
    .main-logo {
      position: fixed;
      top: 60px;
      left: 60px;
      width: 300px;
      max-width: 65vw;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }
    
    .main-logo svg {
      width: 100%;
      height: auto;
    }
    
    @media (max-width: 800px) {
      .main-logo {
        top: 50px;
        right: 50px;
        width: 210px;
        max-width: calc(65vw * 0.7);
      }
    }
  </style>
</head>
<body>
  <div id="fps">FPS: --</div>
  
  <!-- Earendil Logo -->
  <div class="main-logo" id="logo">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 324.14 245.98">
      <defs>
        <style>.st0 { fill: #fff; }</style>
      </defs>
      <g>
        <path class="st0" d="M28.2,224.5v-27.64h19.92v6.05h-12.41v4.75h11.39v6.04h-11.39v4.75h12.36v6.05h-19.87Z"/>
        <path class="st0" d="M70.42,224.5h-8.1l9.12-27.64h10.26l9.12,27.64h-8.1l-6.04-20.03h-.22l-6.05,20.03h0ZM68.91,213.6h15.22v5.61h-15.22v-5.61Z"/>
        <path class="st0" d="M104.87,224.5v-27.64h11.93c2.05,0,3.85.37,5.38,1.12,1.54.75,2.73,1.82,3.59,3.23s1.28,3.09,1.28,5.05-.44,3.65-1.32,5.01-2.11,2.38-3.68,3.08c-1.58.69-3.42,1.04-5.53,1.04h-7.12v-5.83h5.61c.88,0,1.63-.11,2.26-.33.62-.22,1.11-.57,1.44-1.06.34-.49.51-1.12.51-1.9s-.17-1.44-.51-1.94-.82-.87-1.44-1.11c-.63-.24-1.38-.36-2.26-.36h-2.64v21.64h-7.5ZM121.06,211.82l6.91,12.68h-8.15l-6.75-12.68h7.99Z"/>
        <path class="st0" d="M141.64,224.5v-27.64h19.92v6.05h-12.41v4.75h11.39v6.04h-11.39v4.75h12.36v6.05h-19.87Z"/>
        <path class="st0" d="M200.59,196.87v27.64h-6.26l-9.99-14.52h-.16v14.52h-7.5v-27.64h6.37l9.82,14.47h.22v-14.47h7.5Z"/>
        <path class="st0" d="M226.19,224.5h-10.63v-27.64h10.53c2.84,0,5.3.55,7.38,1.65,2.07,1.1,3.67,2.69,4.8,4.75s1.69,4.54,1.69,7.42-.56,5.35-1.69,7.42c-1.12,2.06-2.72,3.65-4.78,4.75-2.06,1.1-4.49,1.65-7.3,1.65ZM223.06,218.13h2.86c1.37,0,2.54-.22,3.5-.66.97-.44,1.71-1.2,2.21-2.28.51-1.08.76-2.58.76-4.51s-.26-3.43-.78-4.51-1.27-1.84-2.27-2.28c-.99-.44-2.21-.66-3.65-.66h-2.64v14.9h.01Z"/>
        <path class="st0" d="M262.31,196.87v27.64h-7.5v-27.64h7.5Z"/>
        <path class="st0" d="M277.27,224.5v-27.64h7.5v21.59h11.17v6.05h-18.68.01Z"/>
      </g>
      <path class="st0" d="M202.89,123.89c.4,29.74-40.27,26.97-40.8,48.11h-.05c-.52-21.14-41.19-18.38-40.8-48.11,27.99,0,40.09-46.29,40.82-101.27.74,54.98,12.83,101.27,40.82,101.27h0Z"/>
    </svg>
  </div>
  
  <canvas id="canvas"></canvas>
  <script>
    // Show FPS counter only if ?fps is in URL
    const fpsDisplay = document.getElementById('fps');
    if (new URLSearchParams(window.location.search).has('fps')) {
      fpsDisplay.classList.add('visible');
    }

    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');

    const vertexShaderSource = `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    // Dither post-process shaders
    const ditherVertexShaderSource = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;

    // Film grain post-process shader (MIT licensed, based on martinsh/devlog-film-grain)
    const ditherFragmentShaderSource = `
      precision highp float;
      uniform sampler2D u_image;
      uniform vec2 u_resolution;
      uniform float u_time;
      varying vec2 v_texCoord;

      #define INTENSITY 0.18
      #define SPEED 2.0
      #define MEAN 0.0
      #define VARIANCE 0.5

      float gaussian(float z, float u, float o) {
        return (1.0 / (o * sqrt(2.0 * 3.1415))) * exp(-(((z - u) * (z - u)) / (2.0 * (o * o))));
      }

      void main() {
        vec4 color = texture2D(u_image, v_texCoord);
        
        // Convert to grayscale
        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
        
        // Film grain noise
        float t = u_time * SPEED;
        vec2 uv = gl_FragCoord.xy / u_resolution;
        float seed = dot(uv, vec2(12.9898, 78.233));
        float noise = fract(sin(seed) * 43758.5453 + t);
        noise = gaussian(noise, MEAN, VARIANCE * VARIANCE);
        
        // Apply grain (addition blend mode)
        vec3 grain = vec3(noise) * (1.0 - vec3(gray));
        gray = gray + grain.r * INTENSITY;
        gray = clamp(gray, 0.0, 1.0);
        
        // Map to color palette
        vec3 dark = vec3(0.235);   // #3c3c3c
        vec3 light = vec3(0.836);  // #d5d5d5
        gl_FragColor = vec4(mix(dark, light, gray), 1.0);
      }
    `;

    const lightDecayFragmentShaderSource = `
      precision highp float;
      uniform sampler2D u_light;
      uniform float u_decay;
      uniform float u_cutoff;
      varying vec2 v_texCoord;

      void main() {
        vec4 color = texture2D(u_light, v_texCoord);
        float intensity = color.r * u_decay - 0.004; // linear term breaks 8-bit quantization
        intensity = max(0.0, intensity);
        intensity *= step(u_cutoff, intensity);
        gl_FragColor = vec4(vec3(intensity), intensity);
      }
    `;

    const lightPointVertexShaderSource = `
      attribute vec2 a_position;
      attribute vec4 a_uvDeriv;  // (du/dx, dv/dx, du/dy, dv/dy)
      attribute float a_screenRadius;  // desired radius in screen units
      uniform vec2 u_texSize;
      varying vec4 v_uvDeriv;
      varying float v_screenRadius;
      varying float v_pointSize;

      void main() {
        gl_Position = vec4(a_position * 2.0 - 1.0, 0.0, 1.0);
        // Compute pixel radius needed to cover screen radius in UV space
        vec2 uvDerivX = a_uvDeriv.xy;
        vec2 uvDerivY = a_uvDeriv.zw;
        vec2 pixelDerivX = uvDerivX * u_texSize;
        vec2 pixelDerivY = uvDerivY * u_texSize;
        float pixelRadiusX = length(pixelDerivX) * a_screenRadius;
        float pixelRadiusY = length(pixelDerivY) * a_screenRadius;
        float pixelRadius = max(pixelRadiusX, pixelRadiusY);
        gl_PointSize = pixelRadius * 2.0 + 2.0;
        v_pointSize = gl_PointSize;
        v_uvDeriv = a_uvDeriv;
        v_screenRadius = a_screenRadius;
      }
    `;

    const LIGHT_INTENSITY = 1.0;
    const PAINT_INTENSITY = LIGHT_INTENSITY / 3;

    const lightPointFragmentShaderSource = `
      precision highp float;
      uniform vec2 u_texSize;
      varying vec4 v_uvDeriv;
      varying float v_screenRadius;
      varying float v_pointSize;

      void main() {
        // Convert gl_PointCoord to UV offset
        vec2 pixelOffset = (gl_PointCoord - 0.5) * v_pointSize;
        vec2 uvOffset = pixelOffset / u_texSize;

        // Invert Jacobian to map UV offset back to screen offset
        float du_dx = v_uvDeriv.x;
        float dv_dx = v_uvDeriv.y;
        float du_dy = v_uvDeriv.z;
        float dv_dy = v_uvDeriv.w;
        float det = du_dx * dv_dy - du_dy * dv_dx;
        vec2 screenOffset = uvOffset;
        if (abs(det) > 1e-12) {
          mat2 invJ = mat2(dv_dy, -dv_dx, -du_dy, du_dx) / det;
          screenOffset = invJ * uvOffset;
        }

        float dist = length(screenOffset) / v_screenRadius;
        float falloff = smoothstep(1.0, 0.0, dist);
        float intensity = falloff * ${PAINT_INTENSITY};
        gl_FragColor = vec4(vec3(intensity), intensity);
      }
    `;

    const fragmentShaderSource = `
      precision highp float;
      uniform vec2 iResolution;
      uniform float iTime;
      uniform sampler2D u_light;

      // afl_ext 2017-2024
      // MIT License
      #define PI 3.14159265359

      #define DRAG_MULT 0.38
      #define WATER_DEPTH 1.0
      #define CAMERA_HEIGHT 1.5
      #define ITERATIONS_RAYMARCH 8
      #define ITERATIONS_NORMAL 16

      vec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {
        float x = dot(direction, position) * frequency + timeshift;
        float wave = exp(sin(x) - 1.0);
        float dx = wave * cos(x);
        return vec2(wave, -dx);
      }

      float getwaves(vec2 position, int iterations) {
        float wavePhaseShift = length(position) * 0.1;
        float iter = 0.0;
        float frequency = 1.0;
        float timeMultiplier = 2.0;
        float weight = 1.0;
        float sumOfValues = 0.0;
        float sumOfWeights = 0.0;
        for(int i=0; i < 16; i++) {
          if(i >= iterations) break;
          vec2 p = vec2(sin(iter), cos(iter));
          vec2 res = wavedx(position, p, frequency, iTime * timeMultiplier + wavePhaseShift);
          position += p * res.y * weight * DRAG_MULT;
          sumOfValues += res.x * weight;
          sumOfWeights += weight;
          weight = mix(weight, 0.0, 0.2);
          frequency *= 1.18;
          timeMultiplier *= 1.07;
          iter += 1232.399963;
        }
        float baseWaves = sumOfValues / sumOfWeights;

        vec2 swellDir = normalize(vec2(0.25, -1.0));
        float swellPhase = dot(position, swellDir) * 0.18 - iTime * 0.08;
        float swell = 0.5 + 0.5 * sin(swellPhase);
        swell = pow(swell, 2.0);
        vec2 cameraPos = vec2(iTime * 0.2, 1.0);
        float swellFade = smoothstep(28.0, 4.0, length(position - cameraPos));

        return baseWaves + swell * swellFade * 0.35;
      }

      float raymarchwater(vec3 camera, vec3 start, vec3 end, float depth) {
        vec3 pos = start;
        vec3 dir = normalize(end - start);
        for(int i=0; i < 32; i++) {
          float height = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;
          if(height + 0.01 > pos.y) {
            return distance(pos, camera);
          }
          pos += dir * (pos.y - height);
        }
        return distance(start, camera);
      }

      vec3 normal(vec2 pos, float e, float depth) {
        vec2 ex = vec2(e, 0);
        float H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;
        vec3 a = vec3(pos.x, H, pos.y);
        return normalize(
          cross(
            a - vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y), 
            a - vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e)
          )
        );
      }

      mat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        return mat3(
          oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 
          oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 
          oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c
        );
      }

      vec3 getRay(vec2 fragCoord) {
        vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);
        vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));
        // Fixed camera angle (no mouse movement) - tilted down to show only water
        return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 0.0) 
          * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.05)
          * proj;
      }

      float intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { 
        return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); 
      }

      vec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir) {
        float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);
        float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);
        float raysundt = pow(abs(dot(sundir, raydir)), 2.0);
        float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);
        float mymie = sundt * special_trick * 0.2;
        vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);
        vec3 bluesky= vec3(12.0, 12.0, 13.0) / 22.4 * suncolor;
        vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(12.0, 12.0, 13.0) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));
        bluesky2 *= special_trick * (0.24 + raysundt * 0.24);
        return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0));
      } 

      vec3 getSunDirection() {
        // Static sun position (no movement)
        return normalize(vec3(-0.0773502691896258, 0.6, 0.5773502691896258));
      }

      vec3 getAtmosphere(vec3 dir) {
         return extra_cheap_atmosphere(dir, getSunDirection()) * 0.5;
      }

      float getSun(vec3 dir) { 
        // No visible sun disc
        return 0.0;
      }

      vec2 skyUV(vec3 dir) {
        float u = atan(dir.z, dir.x) / (2.0 * PI) + 0.5;
        float v = clamp(dir.y * 0.5 + 0.5, 0.0, 1.0);
        return vec2(u, v);
      }

      vec3 aces_tonemap(vec3 color) {  
        mat3 m1 = mat3(
          0.59719, 0.07600, 0.02840,
          0.35458, 0.90834, 0.13383,
          0.04823, 0.01566, 0.83777
        );
        mat3 m2 = mat3(
          1.60475, -0.10208, -0.00327,
          -0.53108,  1.10813, -0.07276,
          -0.07367, -0.00605,  1.07602
        );
        vec3 v = m1 * color;  
        vec3 a = v * (v + 0.0245786) - 0.000090537;
        vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
        return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  
      }

      void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        vec3 ray = getRay(fragCoord);
        if(ray.y >= 0.0) {
          float skyLight = texture2D(u_light, skyUV(ray)).r;
          vec3 C = getAtmosphere(ray) + vec3(1.0) * skyLight * 4.0;
          fragColor = vec4(aces_tonemap(C * 2.0), 1.0);   
          return;
        }

        vec3 waterPlaneHigh = vec3(0.0, 0.0, 0.0);
        vec3 waterPlaneLow = vec3(0.0, -WATER_DEPTH, 0.0);
        vec3 origin = vec3(iTime * 0.2, CAMERA_HEIGHT, 1);

        float highPlaneHit = intersectPlane(origin, ray, waterPlaneHigh, vec3(0.0, 1.0, 0.0));
        float lowPlaneHit = intersectPlane(origin, ray, waterPlaneLow, vec3(0.0, 1.0, 0.0));
        vec3 highHitPos = origin + ray * highPlaneHit;
        vec3 lowHitPos = origin + ray * lowPlaneHit;

        float dist = raymarchwater(origin, highHitPos, lowHitPos, WATER_DEPTH);
        vec3 waterHitPos = origin + ray * dist;

        vec3 N = normal(waterHitPos.xz, 0.01, WATER_DEPTH);
        N = mix(N, vec3(0.0, 1.0, 0.0), 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));

        float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));

        vec3 R = normalize(reflect(ray, N));
        R.y = abs(R.y);
        
        float reflectedLight = texture2D(u_light, skyUV(R)).r;
        vec3 reflection = getAtmosphere(R) + vec3(1.0) * reflectedLight * 4.0;
        vec3 scattering = vec3(0.08, 0.08, 0.09) * (0.2 + (waterHitPos.y + WATER_DEPTH) / WATER_DEPTH);

        vec3 C = fresnel * reflection + scattering;
        
        // Add distance fog
        vec3 fogColor = vec3(0.55, 0.55, 0.58);
        float fogAmount = 1.0 - exp(-dist * 0.02);
        C = mix(C, fogColor, fogAmount);
        
        fragColor = vec4(aces_tonemap(C * 2.0), 1.0);
      }

      void main() {
        mainImage(gl_FragColor, gl_FragCoord.xy);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    // Ocean wave program
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1, 1, -1, -1, 1,
      -1, 1, 1, -1, 1, 1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'position');
    const resolutionLocation = gl.getUniformLocation(program, 'iResolution');
    const timeLocation = gl.getUniformLocation(program, 'iTime');
    const lightTextureLocation = gl.getUniformLocation(program, 'u_light');

    // Dither post-process program
    const ditherVertexShader = createShader(gl, gl.VERTEX_SHADER, ditherVertexShaderSource);
    const ditherFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, ditherFragmentShaderSource);
    const ditherProgram = createProgram(gl, ditherVertexShader, ditherFragmentShader);

    const lightDecayFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, lightDecayFragmentShaderSource);
    const lightDecayProgram = createProgram(gl, ditherVertexShader, lightDecayFragmentShader);

    const lightPointVertexShader = createShader(gl, gl.VERTEX_SHADER, lightPointVertexShaderSource);
    const lightPointFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, lightPointFragmentShaderSource);
    const lightPointProgram = createProgram(gl, lightPointVertexShader, lightPointFragmentShader);

    const ditherPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ditherPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    const ditherPositionLocation = gl.getAttribLocation(ditherProgram, 'a_position');
    const lightDecayPositionLocation = gl.getAttribLocation(lightDecayProgram, 'a_position');

    const ditherTexCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ditherTexCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);
    const ditherTexCoordLocation = gl.getAttribLocation(ditherProgram, 'a_texCoord');
    const lightDecayTexCoordLocation = gl.getAttribLocation(lightDecayProgram, 'a_texCoord');

    const ditherResolutionLocation = gl.getUniformLocation(ditherProgram, 'u_resolution');
    const ditherImageLocation = gl.getUniformLocation(ditherProgram, 'u_image');
    const ditherTimeLocation = gl.getUniformLocation(ditherProgram, 'u_time');

    const lightDecayImageLocation = gl.getUniformLocation(lightDecayProgram, 'u_light');
    const lightDecayFactorLocation = gl.getUniformLocation(lightDecayProgram, 'u_decay');
    const lightDecayCutoffLocation = gl.getUniformLocation(lightDecayProgram, 'u_cutoff');

    const lightPointPositionLocation = gl.getAttribLocation(lightPointProgram, 'a_position');
    const lightPointUvDerivLocation = gl.getAttribLocation(lightPointProgram, 'a_uvDeriv');
    const lightPointScreenRadiusLocation = gl.getAttribLocation(lightPointProgram, 'a_screenRadius');
    const lightPointTexSizeLocation = gl.getUniformLocation(lightPointProgram, 'u_texSize');
    const lightPointBuffer = gl.createBuffer();

    // Framebuffer for render-to-texture
    let framebuffer = null;
    let renderTexture = null;
    let fbWidth = 0;
    let fbHeight = 0;

    let lightFramebuffers = [null, null];
    let lightTextures = [null, null];
    let lightWriteIndex = 0;
    let lastLightTime = 0;

    function setupFramebuffer(width, height) {
      if (framebuffer && fbWidth === width && fbHeight === height) return;
      
      if (framebuffer) {
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(renderTexture);
      }

      fbWidth = width;
      fbHeight = height;

      renderTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, renderTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function createLightTexture(width, height) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      return texture;
    }

    function setupLightFramebuffers(width, height) {
      for (let i = 0; i < 2; i++) {
        if (lightFramebuffers[i]) {
          gl.deleteFramebuffer(lightFramebuffers[i]);
          gl.deleteTexture(lightTextures[i]);
        }
        lightTextures[i] = createLightTexture(width, height);
        lightFramebuffers[i] = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, lightFramebuffers[i]);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, lightTextures[i], 0);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      lightWriteIndex = 0;
    }

    function resize() {
      // Render at reduced resolution
      const scale = 0.4;
      canvas.width = window.innerWidth * window.devicePixelRatio * scale;
      canvas.height = window.innerHeight * window.devicePixelRatio * scale;
      setupFramebuffer(canvas.width, canvas.height);
      setupLightFramebuffers(canvas.width, canvas.height);
    }

    window.addEventListener('resize', resize);
    resize();

    // FPS tracking
    let frameCount = 0;
    let lastFpsUpdate = 0;

    const pendingLightPoints = [];
    let isDrawing = false;

    function screenPosToSkyUV(screenX, screenY, aspect) {
      const uvX = screenX * 2 - 1;
      const uvY = screenY * 2 - 1;
      const projX = uvX * aspect;
      const projY = uvY;
      const projZ = 1.5;

      const projLen = Math.hypot(projX, projY, projZ);
      let rayX = projX / projLen;
      let rayY = projY / projLen;
      let rayZ = projZ / projLen;

      const cosTilt = Math.cos(-0.05);
      const sinTilt = Math.sin(-0.05);
      const rotatedY = rayY * cosTilt + rayZ * sinTilt;
      const rotatedZ = -rayY * sinTilt + rayZ * cosTilt;
      rayY = rotatedY;
      rayZ = rotatedZ;

      if (rayY < 0) return null;

      const u = ((Math.atan2(rayZ, rayX) / (2 * Math.PI)) + 0.5) % 1;
      const v = Math.min(1, Math.max(0, rayY * 0.5 + 0.5));
      return { u, v };
    }

    function screenToSkyUV(event) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const xPx = (event.clientX - rect.left) * scaleX;
      const yPx = (rect.height - (event.clientY - rect.top)) * scaleY;
      const x = xPx / canvas.width;
      const y = yPx / canvas.height;
      if (x < 0 || x > 1 || y < 0 || y > 1) return null;

      const aspect = canvas.width / canvas.height;
      const result = screenPosToSkyUV(x, y, aspect);
      if (!result) return null;

      // Compute Jacobian: how much u and v change per device pixel
      const epsPx = 1;
      const rightX = (xPx + epsPx) / canvas.width;
      const leftX = (xPx - epsPx) / canvas.width;
      const upY = (yPx + epsPx) / canvas.height;
      const downY = (yPx - epsPx) / canvas.height;
      const uvRight = screenPosToSkyUV(rightX, y, aspect);
      const uvLeft = screenPosToSkyUV(leftX, y, aspect);
      const uvUp = screenPosToSkyUV(x, upY, aspect);
      const uvDown = screenPosToSkyUV(x, downY, aspect);

      const wrapDelta = (a, b) => {
        let d = a - b;
        if (d > 0.5) d -= 1.0;
        if (d < -0.5) d += 1.0;
        return d;
      };

      let du_dx = 0.001;
      let dv_dx = 0.0;
      let du_dy = 0.0;
      let dv_dy = 0.001;

      if (uvRight && uvLeft) {
        du_dx = wrapDelta(uvRight.u, uvLeft.u) / (2 * epsPx);
        dv_dx = (uvRight.v - uvLeft.v) / (2 * epsPx);
      } else if (uvRight) {
        du_dx = wrapDelta(uvRight.u, result.u) / epsPx;
        dv_dx = (uvRight.v - result.v) / epsPx;
      } else if (uvLeft) {
        du_dx = wrapDelta(result.u, uvLeft.u) / epsPx;
        dv_dx = (result.v - uvLeft.v) / epsPx;
      }

      if (uvUp && uvDown) {
        du_dy = wrapDelta(uvUp.u, uvDown.u) / (2 * epsPx);
        dv_dy = (uvUp.v - uvDown.v) / (2 * epsPx);
      } else if (uvUp) {
        du_dy = wrapDelta(uvUp.u, result.u) / epsPx;
        dv_dy = (uvUp.v - result.v) / epsPx;
      } else if (uvDown) {
        du_dy = wrapDelta(result.u, uvDown.u) / epsPx;
        dv_dy = (result.v - uvDown.v) / epsPx;
      }

      return { u: result.u, v: result.v, du_dx, dv_dx, du_dy, dv_dy };
    }

    function queueLightPoints(event) {
      const skyUV = screenToSkyUV(event);
      if (!skyUV) return;

      const sprinkleCount = 10;
      for (let i = 0; i < sprinkleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = (Math.random() * 10 + 6) * window.devicePixelRatio;
        const offsetX = Math.cos(angle) * radius;
        const offsetY = Math.sin(angle) * radius;

        const jitterU = skyUV.du_dx * offsetX + skyUV.du_dy * offsetY;
        const jitterV = skyUV.dv_dx * offsetX + skyUV.dv_dy * offsetY;

        // Radius in screen pixels (independent of resolution)
        const screenRadius = (Math.random() * 6 + 4) * window.devicePixelRatio;
        const px = (skyUV.u + jitterU + 1) % 1;
        const py = Math.min(1, Math.max(0, skyUV.v + jitterV));
        // 7 floats per point: x, y, du_dx, dv_dx, du_dy, dv_dy, screenRadius
        pendingLightPoints.push(px, py, skyUV.du_dx, skyUV.dv_dx, skyUV.du_dy, skyUV.dv_dy, screenRadius);
      }

      if (pendingLightPoints.length > 4200) {
        pendingLightPoints.splice(0, pendingLightPoints.length - 4200);
      }
    }

    canvas.addEventListener('pointerdown', (event) => {
      isDrawing = true;
      queueLightPoints(event);
    });

    canvas.addEventListener('pointermove', (event) => {
      if (isDrawing) {
        queueLightPoints(event);
      }
    });

    window.addEventListener('pointerup', () => {
      isDrawing = false;
    });

    function updateLightTexture(time) {
      if (!lastLightTime) {
        lastLightTime = time;
      }
      const delta = Math.max(0, (time - lastLightTime) * 0.001);
      lastLightTime = time;
      const fadeDuration = 240;
      const targetIntensity = LIGHT_INTENSITY;
      const decayCutoff = 1 / 255;
      const decayFloor = (1 / 255) / targetIntensity;
      const decay = Math.pow(decayFloor, delta / fadeDuration);
      const readIndex = lightWriteIndex;
      const writeIndex = 1 - lightWriteIndex;

      gl.bindFramebuffer(gl.FRAMEBUFFER, lightFramebuffers[writeIndex]);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.useProgram(lightDecayProgram);

      gl.enableVertexAttribArray(lightDecayPositionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherPositionBuffer);
      gl.vertexAttribPointer(lightDecayPositionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(lightDecayTexCoordLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherTexCoordBuffer);
      gl.vertexAttribPointer(lightDecayTexCoordLocation, 2, gl.FLOAT, false, 0, 0);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, lightTextures[readIndex]);
      gl.uniform1i(lightDecayImageLocation, 0);
      gl.uniform1f(lightDecayFactorLocation, decay);
      gl.uniform1f(lightDecayCutoffLocation, decayCutoff);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      if (pendingLightPoints.length > 0) {
        gl.useProgram(lightPointProgram);
        gl.uniform2f(lightPointTexSizeLocation, canvas.width, canvas.height);
        gl.bindBuffer(gl.ARRAY_BUFFER, lightPointBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pendingLightPoints), gl.DYNAMIC_DRAW);

        // 7 floats per vertex: x, y, du_dx, dv_dx, du_dy, dv_dy, screenRadius (28 bytes)
        gl.enableVertexAttribArray(lightPointPositionLocation);
        gl.vertexAttribPointer(lightPointPositionLocation, 2, gl.FLOAT, false, 28, 0);

        gl.enableVertexAttribArray(lightPointUvDerivLocation);
        gl.vertexAttribPointer(lightPointUvDerivLocation, 4, gl.FLOAT, false, 28, 8);

        gl.enableVertexAttribArray(lightPointScreenRadiusLocation);
        gl.vertexAttribPointer(lightPointScreenRadiusLocation, 1, gl.FLOAT, false, 28, 24);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE);
        gl.drawArrays(gl.POINTS, 0, pendingLightPoints.length / 7);
        gl.disable(gl.BLEND);

        pendingLightPoints.length = 0;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      lightWriteIndex = writeIndex;
    }

    function render(time) {
      // Update FPS counter
      frameCount++;
      if (time - lastFpsUpdate >= 1000) {
        fpsDisplay.textContent = `FPS: ${frameCount} | ${canvas.width}x${canvas.height}`;
        frameCount = 0;
        lastFpsUpdate = time;
      }

      updateLightTexture(time);

      // Pass 1: Render ocean waves to framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.useProgram(program);
      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(timeLocation, time * 0.001);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, lightTextures[lightWriteIndex]);
      gl.uniform1i(lightTextureLocation, 1);
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Pass 2: Apply dither post-processing to screen
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.useProgram(ditherProgram);

      gl.enableVertexAttribArray(ditherPositionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherPositionBuffer);
      gl.vertexAttribPointer(ditherPositionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(ditherTexCoordLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherTexCoordBuffer);
      gl.vertexAttribPointer(ditherTexCoordLocation, 2, gl.FLOAT, false, 0, 0);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, renderTexture);
      gl.uniform1i(ditherImageLocation, 0);
      gl.uniform2f(ditherResolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(ditherTimeLocation, time * 0.001);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // Logo fade-in animation
    const logo = document.getElementById('logo');
    setTimeout(() => {
      logo.style.transition = 'opacity 5s ease';
      logo.style.opacity = '0.85';
    }, 600);
  </script>
</body>
</html>
