<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ocean Waves</title>
  <style>
    * { margin: 0; padding: 0; }
    html, body {
      overflow: hidden;
      cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g fill="white" opacity="0.95"><path d="M12 0.6 L13.1 11.6 L10.9 11.6 Z"/><path d="M12 0.6 L13.1 11.6 L10.9 11.6 Z" transform="rotate(180 12 12)"/><path d="M23.2 12 L12.4 12.9 L12.4 11.1 Z"/><path d="M23.2 12 L12.4 12.9 L12.4 11.1 Z" transform="rotate(180 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(45 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(135 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(225 12 12)"/><path d="M12 5.8 L12.9 12 L11.1 12 Z" transform="rotate(315 12 12)"/><path d="M12 9.4 L13.1 12 L12 14.6 L10.9 12 Z" opacity="0.85"/><circle cx="12" cy="12" r="0.6" opacity="0.85"/></g></svg>') 12 12, auto;
    }
    * { cursor: inherit; }
    canvas { display: block; width: 100vw; height: 100vh; image-rendering: auto; }
    #fps { position: fixed; top: 10px; left: 10px; color: white; font: 16px monospace; background: rgba(0,0,0,0.5); padding: 5px 10px; z-index: 100; display: none; }
    #fps.visible { display: block; }

    #theme-toggle {
      position: fixed;
      bottom: 20px;
      right: 20px;
      border: 0;
      background: none;
      color: rgba(255, 255, 255, 0.95);
      font: 26px/1 "Segoe UI Symbol", "Apple Symbols", "Noto Sans Symbols", "Arial", sans-serif;
      font-variant-emoji: text;
      padding: 6px;
      z-index: 120;
      cursor: pointer;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.45);
      transition: transform 0.2s ease, color 0.2s ease;
    }

    #theme-toggle:hover {
      color: rgba(255, 255, 255, 1);
      transform: scale(1.08);
    }

    #theme-toggle:active {
      transform: scale(0.98);
    }
    
    /* Logo styles */
    .main-logo {
      position: fixed;
      top: 60px;
      left: 60px;
      width: 300px;
      max-width: 65vw;
      z-index: 10;
      opacity: 0;
      pointer-events: none;
    }
    
    .main-logo svg {
      width: 100%;
      height: auto;
    }
    
    @media (max-width: 800px) {
      .main-logo {
        top: 50px;
        right: 50px;
        width: 210px;
        max-width: calc(65vw * 0.7);
      }
    }
  </style>
</head>
<body>
  <div id="fps">FPS: --</div>
  <button id="theme-toggle" type="button" aria-label="Toggle color theme"></button>
  
  <!-- Earendil Logo -->
  <div class="main-logo" id="logo">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 324.14 245.98">
      <defs>
        <style>.st0 { fill: #fff; }</style>
      </defs>
      <g>
        <path class="st0" d="M28.2,224.5v-27.64h19.92v6.05h-12.41v4.75h11.39v6.04h-11.39v4.75h12.36v6.05h-19.87Z"/>
        <path class="st0" d="M70.42,224.5h-8.1l9.12-27.64h10.26l9.12,27.64h-8.1l-6.04-20.03h-.22l-6.05,20.03h0ZM68.91,213.6h15.22v5.61h-15.22v-5.61Z"/>
        <path class="st0" d="M104.87,224.5v-27.64h11.93c2.05,0,3.85.37,5.38,1.12,1.54.75,2.73,1.82,3.59,3.23s1.28,3.09,1.28,5.05-.44,3.65-1.32,5.01-2.11,2.38-3.68,3.08c-1.58.69-3.42,1.04-5.53,1.04h-7.12v-5.83h5.61c.88,0,1.63-.11,2.26-.33.62-.22,1.11-.57,1.44-1.06.34-.49.51-1.12.51-1.9s-.17-1.44-.51-1.94-.82-.87-1.44-1.11c-.63-.24-1.38-.36-2.26-.36h-2.64v21.64h-7.5ZM121.06,211.82l6.91,12.68h-8.15l-6.75-12.68h7.99Z"/>
        <path class="st0" d="M141.64,224.5v-27.64h19.92v6.05h-12.41v4.75h11.39v6.04h-11.39v4.75h12.36v6.05h-19.87Z"/>
        <path class="st0" d="M200.59,196.87v27.64h-6.26l-9.99-14.52h-.16v14.52h-7.5v-27.64h6.37l9.82,14.47h.22v-14.47h7.5Z"/>
        <path class="st0" d="M226.19,224.5h-10.63v-27.64h10.53c2.84,0,5.3.55,7.38,1.65,2.07,1.1,3.67,2.69,4.8,4.75s1.69,4.54,1.69,7.42-.56,5.35-1.69,7.42c-1.12,2.06-2.72,3.65-4.78,4.75-2.06,1.1-4.49,1.65-7.3,1.65ZM223.06,218.13h2.86c1.37,0,2.54-.22,3.5-.66.97-.44,1.71-1.2,2.21-2.28.51-1.08.76-2.58.76-4.51s-.26-3.43-.78-4.51-1.27-1.84-2.27-2.28c-.99-.44-2.21-.66-3.65-.66h-2.64v14.9h.01Z"/>
        <path class="st0" d="M262.31,196.87v27.64h-7.5v-27.64h7.5Z"/>
        <path class="st0" d="M277.27,224.5v-27.64h7.5v21.59h11.17v6.05h-18.68.01Z"/>
      </g>
      <path class="st0" d="M202.89,123.89c.4,29.74-40.27,26.97-40.8,48.11h-.05c-.52-21.14-41.19-18.38-40.8-48.11,27.99,0,40.09-46.29,40.82-101.27.74,54.98,12.83,101.27,40.82,101.27h0Z"/>
    </svg>
  </div>
  
  <canvas id="canvas"></canvas>
  <script>
    // Show FPS counter only if ?fps is in URL
    const fpsDisplay = document.getElementById('fps');
    if (new URLSearchParams(window.location.search).has('fps')) {
      fpsDisplay.classList.add('visible');
    }

    const canvas = document.getElementById('canvas');
    const logo = document.getElementById('logo');
    const themeToggle = document.getElementById('theme-toggle');
    const gl = canvas.getContext('webgl');

    const THEME_STORAGE_KEY = 'earendil-theme-mode';
    const THEME_MODES = ['auto', 'night', 'day'];
    const THEME_ICONS = {
      auto: '◐',
      night: '☾',
      day: '☀'
    };

    // Quality settings for slower computers
    const QUALITY_LEVELS = ['low', 'medium', 'high'];
    const QUALITY_SETTINGS = {
      low: {
        scale: 0.25,
        raymarchSteps: 20,
        waveIterRaymarch: 4,
        waveIterNormal: 16,
        fbmOctaves: 2
      },
      medium: {
        scale: 0.35,
        raymarchSteps: 24,
        waveIterRaymarch: 6,
        waveIterNormal: 16,
        fbmOctaves: 3
      },
      high: {
        scale: 0.4,
        raymarchSteps: 32,
        waveIterRaymarch: 8,
        waveIterNormal: 16,
        fbmOctaves: 4
      }
    };

    let currentQuality = 'high';

    // Adaptive quality settings
    const AUTO_QUALITY_FPS_LOW = 28;      // Drop quality if FPS below this
    const AUTO_QUALITY_FPS_HIGH = 55;     // Increase quality if FPS above this
    const AUTO_QUALITY_SAMPLE_TIME = 2000; // Time window to average FPS (ms)
    const AUTO_QUALITY_COOLDOWN = 4000;   // Minimum time between quality changes (ms)
    let autoQualityFpsHistory = [];
    let lastQualityChangeTime = 0;

    function loadThemeMode() {
      try {
        const stored = localStorage.getItem(THEME_STORAGE_KEY);
        if (THEME_MODES.includes(stored)) {
          return stored;
        }
      } catch (error) {
        console.warn('Unable to access localStorage for theme mode.', error);
      }
      return 'auto';
    }

    let themeMode = loadThemeMode();

    const colorSchemeQuery = window.matchMedia
      ? window.matchMedia('(prefers-color-scheme: dark)')
      : null;
    let prefersNight = colorSchemeQuery ? colorSchemeQuery.matches : false;

    if (colorSchemeQuery) {
      const onSchemeChange = (event) => {
        prefersNight = event.matches;
      };
      if (colorSchemeQuery.addEventListener) {
        colorSchemeQuery.addEventListener('change', onSchemeChange);
      } else if (colorSchemeQuery.addListener) {
        colorSchemeQuery.addListener(onSchemeChange);
      }
    }

    function getNightPreference() {
      if (themeMode === 'auto') {
        return prefersNight;
      }
      return themeMode === 'night';
    }

    function updateThemeToggle() {
      themeToggle.textContent = THEME_ICONS[themeMode] || THEME_ICONS.auto;
      themeToggle.setAttribute('aria-label', `Theme: ${themeMode}`);
    }

    function persistThemeMode() {
      try {
        localStorage.setItem(THEME_STORAGE_KEY, themeMode);
      } catch (error) {
        console.warn('Unable to persist theme mode.', error);
      }
    }

    themeToggle.addEventListener('click', () => {
      const currentIndex = THEME_MODES.indexOf(themeMode);
      const nextIndex = (currentIndex + 1) % THEME_MODES.length;
      themeMode = THEME_MODES[nextIndex];
      persistThemeMode();
      updateThemeToggle();
    });

    updateThemeToggle();

    const vertexShaderSource = `
      attribute vec2 position;
      void main() {
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    // Dither post-process shaders
    const ditherVertexShaderSource = `
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      varying vec2 v_texCoord;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
        v_texCoord = a_texCoord;
      }
    `;

    // Film grain post-process shader (MIT licensed, based on martinsh/devlog-film-grain)
    const ditherFragmentShaderSource = `
      precision highp float;
      uniform sampler2D u_image;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform float u_night;
      varying vec2 v_texCoord;

      #define INTENSITY 0.18
      #define SPEED 2.0
      #define MEAN 0.0
      #define VARIANCE 0.5

      float gaussian(float z, float u, float o) {
        return (1.0 / (o * sqrt(2.0 * 3.1415))) * exp(-(((z - u) * (z - u)) / (2.0 * (o * o))));
      }

      void main() {
        vec4 color = texture2D(u_image, v_texCoord);
        
        // Convert to grayscale
        float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
        
        // Film grain noise
        float t = u_time * SPEED;
        vec2 uv = gl_FragCoord.xy / u_resolution;
        float seed = dot(uv, vec2(12.9898, 78.233));
        float noise = fract(sin(seed) * 43758.5453 + t);
        noise = gaussian(noise, MEAN, VARIANCE * VARIANCE);
        
        // Apply grain (addition blend mode)
        vec3 grain = vec3(noise) * (1.0 - vec3(gray));
        float grainIntensity = mix(INTENSITY, 0.05, u_night);
        gray = gray + grain.r * grainIntensity;
        gray = clamp(gray, 0.0, 1.0);
        
        // Map to color palette
        vec3 dark = mix(vec3(0.235), vec3(0.02), u_night);   // #3c3c3c -> #050505
        vec3 light = mix(vec3(0.836), vec3(1.0), u_night);   // #d5d5d5 -> #ffffff
        gl_FragColor = vec4(mix(dark, light, gray), 1.0);
      }
    `;

    const lightDecayFragmentShaderSource = `
      precision highp float;
      uniform sampler2D u_light;
      uniform float u_decay;
      uniform float u_cutoff;
      varying vec2 v_texCoord;

      void main() {
        vec4 color = texture2D(u_light, v_texCoord);
        float intensity = color.r * u_decay - 0.004; // linear term breaks 8-bit quantization
        intensity = max(0.0, intensity);
        intensity *= step(u_cutoff, intensity);
        gl_FragColor = vec4(vec3(intensity), intensity);
      }
    `;

    const lightPointVertexShaderSource = `
      attribute vec2 a_position;
      attribute vec4 a_uvDeriv;  // (du/dx, dv/dx, du/dy, dv/dy)
      attribute float a_screenRadius;  // desired radius in screen units
      uniform vec2 u_texSize;
      varying vec4 v_uvDeriv;
      varying float v_screenRadius;
      varying float v_pointSize;

      void main() {
        gl_Position = vec4(a_position * 2.0 - 1.0, 0.0, 1.0);
        // Compute pixel radius needed to cover screen radius in UV space
        vec2 uvDerivX = a_uvDeriv.xy;
        vec2 uvDerivY = a_uvDeriv.zw;
        vec2 pixelDerivX = uvDerivX * u_texSize;
        vec2 pixelDerivY = uvDerivY * u_texSize;
        float pixelRadiusX = length(pixelDerivX) * a_screenRadius;
        float pixelRadiusY = length(pixelDerivY) * a_screenRadius;
        float pixelRadius = max(pixelRadiusX, pixelRadiusY);
        gl_PointSize = pixelRadius * 2.0 + 2.0;
        v_pointSize = gl_PointSize;
        v_uvDeriv = a_uvDeriv;
        v_screenRadius = a_screenRadius;
      }
    `;

    const LIGHT_INTENSITY = 1.0;
    const PAINT_INTENSITY = LIGHT_INTENSITY / 3;
    const LOGO_FADE_DELAY = 600;
    const LOGO_FADE_DURATION = 5000;
    const LOGO_FADE_TARGET = 0.85;

    const lightPointFragmentShaderSource = `
      precision highp float;
      uniform vec2 u_texSize;
      varying vec4 v_uvDeriv;
      varying float v_screenRadius;
      varying float v_pointSize;

      void main() {
        // Convert gl_PointCoord to UV offset
        vec2 pixelOffset = (gl_PointCoord - 0.5) * v_pointSize;
        vec2 uvOffset = pixelOffset / u_texSize;

        // Invert Jacobian to map UV offset back to screen offset
        float du_dx = v_uvDeriv.x;
        float dv_dx = v_uvDeriv.y;
        float du_dy = v_uvDeriv.z;
        float dv_dy = v_uvDeriv.w;
        float det = du_dx * dv_dy - du_dy * dv_dx;
        vec2 screenOffset = uvOffset;
        if (abs(det) > 1e-12) {
          mat2 invJ = mat2(dv_dy, -dv_dx, -du_dy, du_dx) / det;
          screenOffset = invJ * uvOffset;
        }

        float dist = length(screenOffset) / v_screenRadius;
        float falloff = smoothstep(1.0, 0.0, dist);
        float intensity = falloff * ${PAINT_INTENSITY};
        gl_FragColor = vec4(vec3(intensity), intensity);
      }
    `;

    function buildFragmentShader(quality) {
      const settings = QUALITY_SETTINGS[quality];
      return `
      precision highp float;
      uniform vec2 iResolution;
      uniform float iTime;
      uniform sampler2D u_light;
      uniform sampler2D u_logo;
      uniform vec2 u_logoCenter;
      uniform vec2 u_logoSize;
      uniform float u_logoFade;
      uniform vec4 u_ripples[10]; // (worldX, worldZ, birthTime, amplitude)
      uniform int u_rippleCount;
      uniform float u_night;
      uniform float u_ambientIntensity;

      // afl_ext 2017-2024
      // MIT License
      #define PI 3.14159265359

      #define DRAG_MULT 0.38
      #define WATER_DEPTH 1.0
      #define CAMERA_HEIGHT 1.5
      #define ITERATIONS_RAYMARCH ${settings.waveIterRaymarch}
      #define ITERATIONS_NORMAL ${settings.waveIterNormal}
      #define RAYMARCH_STEPS ${settings.raymarchSteps}
      #define FBM_OCTAVES ${settings.fbmOctaves}
      #define LOGO_INTENSITY 3.5

      float hash21(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
      }

      float noise21(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        f = f * f * (3.0 - 2.0 * f);
        float a = hash21(i);
        float b = hash21(i + vec2(1.0, 0.0));
        float c = hash21(i + vec2(0.0, 1.0));
        float d = hash21(i + vec2(1.0, 1.0));
        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
      }

      float fbm(vec2 p) {
        float value = 0.0;
        float amplitude = 0.5;
        float frequency = 1.0;
        for (int i = 0; i < FBM_OCTAVES; i++) {
          value += amplitude * noise21(p * frequency);
          frequency *= 2.0;
          amplitude *= 0.5;
        }
        return value;
      }

      mat3 createRotationMatrixAxisAngle(vec3 axis, float angle);

      vec2 dirToScreenUV(vec3 dir) {
        vec3 unrotated = createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.05) * dir;
        if (unrotated.z <= 0.0) return vec2(-1.0);
        vec2 uv = (unrotated.xy / unrotated.z) * 1.5;
        vec2 ndc = uv / vec2(iResolution.x / iResolution.y, 1.0);
        return ndc * 0.5 + 0.5;
      }

      float star(vec2 screenUv, vec2 cellId, vec2 grid) {
        float rnd = hash21(cellId);
        if (rnd > 0.9) return 0.0;
        vec2 starPos = vec2(hash21(cellId + 0.1), hash21(cellId + 0.2));
        vec2 starUv = (cellId + starPos) / grid;
        vec2 deltaPx = (screenUv - starUv) * iResolution.xy;
        float sizePx = 0.3 + hash21(cellId + 0.3) * 0.25;
        float d = length(deltaPx);
        float core = smoothstep(sizePx, sizePx * 0.2, d);
        float flickerPhase = hash21(cellId + 0.4) * 6.28318;
        float flickerSpeed = 0.2 + hash21(cellId + 0.5) * 0.3;
        float flicker = 0.75 + 0.25 * sin(iTime * flickerSpeed + flickerPhase);
        return core * flicker;
      }

      vec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {
        float x = dot(direction, position) * frequency + timeshift;
        float wave = exp(sin(x) - 1.0);
        float dx = wave * cos(x);
        return vec2(wave, -dx);
      }

      float getripples(vec2 position) {
        float rippleSum = 0.0;
        for (int i = 0; i < 10; i++) {
          if (i >= u_rippleCount) break;
          vec4 ripple = u_ripples[i];
          vec2 ripplePos = ripple.xy;
          float birthTime = ripple.z;
          float amplitude = ripple.w;
          
          float age = iTime - birthTime;
          if (age < 0.0 || age > 12.0) continue;
          
          float dist = length(position - ripplePos);
          float frequency = 2.5;
          float speed = 3.0;
          float decay = 0.4;
          float spatialDecay = 0.08;
          
          // Circular wave propagating outward with decay
          float phase = dist * frequency - age * speed;
          float envelope = exp(-decay * age) * exp(-dist * spatialDecay);
          // Smooth start to avoid pop-in
          float fadeIn = smoothstep(0.0, 0.3, age);
          rippleSum += amplitude * envelope * fadeIn * sin(phase);
        }
        return rippleSum;
      }

      // Base wave calculation without ripples (used for raymarching)
      float getwaves_base(vec2 position, int iterations) {
        float wavePhaseShift = length(position) * 0.1;
        float iter = 0.0;
        float frequency = 1.0;
        float timeMultiplier = 2.0;
        float weight = 1.0;
        float sumOfValues = 0.0;
        float sumOfWeights = 0.0;
        for(int i=0; i < 16; i++) {
          if(i >= iterations) break;
          vec2 p = vec2(sin(iter), cos(iter));
          vec2 res = wavedx(position, p, frequency, iTime * timeMultiplier + wavePhaseShift);
          position += p * res.y * weight * DRAG_MULT;
          sumOfValues += res.x * weight;
          sumOfWeights += weight;
          weight = mix(weight, 0.0, 0.2);
          frequency *= 1.18;
          timeMultiplier *= 1.07;
          iter += 1232.399963;
        }
        float baseWaves = sumOfValues / sumOfWeights;

        vec2 swellDir = normalize(vec2(0.25, -1.0));
        float swellPhase = dot(position, swellDir) * 0.18 - iTime * 0.08;
        float swell = 0.5 + 0.5 * sin(swellPhase);
        swell = pow(swell, 2.0);
        vec2 cameraPos = vec2(iTime * 0.2, 1.0);
        float swellFade = smoothstep(28.0, 4.0, length(position - cameraPos));

        return baseWaves + swell * swellFade * 0.35;
      }

      // Full wave calculation with ripples (used for normal calculation)
      float getwaves(vec2 position, int iterations) {
        return getwaves_base(position, iterations) + getripples(position);
      }

      float raymarchwater(vec3 camera, vec3 start, vec3 end, float depth) {
        vec3 pos = start;
        vec3 dir = normalize(end - start);
        for(int i=0; i < RAYMARCH_STEPS; i++) {
          float height = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;
          if(height + 0.01 > pos.y) {
            return distance(pos, camera);
          }
          pos += dir * (pos.y - height);
        }
        return distance(start, camera);
      }

      vec3 normal(vec2 pos, float e, float depth) {
        vec2 ex = vec2(e, 0);
        float H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;
        vec3 a = vec3(pos.x, H, pos.y);
        return normalize(
          cross(
            a - vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y), 
            a - vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e)
          )
        );
      }

      mat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {
        float s = sin(angle);
        float c = cos(angle);
        float oc = 1.0 - c;
        return mat3(
          oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 
          oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 
          oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c
        );
      }

      vec3 getRay(vec2 fragCoord) {
        vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);
        vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));
        // Fixed camera angle (no mouse movement) - tilted down to show only water
        return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 0.0) 
          * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), -0.05)
          * proj;
      }

      float intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { 
        return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); 
      }

      vec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir) {
        float special_trick = 1.0 / (raydir.y * 1.0 + 0.1);
        float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);
        float raysundt = pow(abs(dot(sundir, raydir)), 2.0);
        float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);
        float mymie = sundt * special_trick * 0.2;
        vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);
        vec3 bluesky= vec3(12.0, 12.0, 13.0) / 22.4 * suncolor;
        vec3 bluesky2 = max(vec3(0.0), bluesky - vec3(12.0, 12.0, 13.0) * 0.002 * (special_trick + -6.0 * sundir.y * sundir.y));
        bluesky2 *= special_trick * (0.24 + raysundt * 0.24);
        return bluesky2 * (1.0 + 1.0 * pow(1.0 - raydir.y, 3.0));
      } 

      vec3 getSunDirection() {
        // Static sun position (no movement)
        return normalize(vec3(-0.0773502691896258, 0.6, 0.5773502691896258));
      }

      vec3 getAtmosphere(vec3 dir) {
         return extra_cheap_atmosphere(dir, getSunDirection()) * 0.5;
      }

      float getSun(vec3 dir) { 
        // No visible sun disc
        return 0.0;
      }

      vec2 skyUV(vec3 dir) {
        float u = atan(dir.z, dir.x) / (2.0 * PI) + 0.5;
        float v = clamp(dir.y * 0.5 + 0.5, 0.0, 1.0);
        return vec2(u, v);
      }

      vec3 getDaySky(vec3 dir, float skyLight) {
        return getAtmosphere(dir) + vec3(1.0) * skyLight * 4.0 * u_ambientIntensity;
      }

      vec3 getNightSky(vec3 dir, float skyLight) {
        vec2 uv = skyUV(dir);
        vec3 topColor = vec3(0.015, 0.02, 0.04);
        vec3 bottomColor = vec3(0.03, 0.035, 0.05);
        vec3 color = mix(bottomColor, topColor, uv.y);

        vec2 screenUv = dirToScreenUV(dir);
        if (screenUv.x >= 0.0 && screenUv.x <= 1.0 && screenUv.y >= 0.0 && screenUv.y <= 1.0) {
          if (screenUv.y > 0.35) {
            float gridX = 40.0;
            float gridY = 30.0;
            vec2 grid = vec2(gridX, gridY);
            vec2 baseCell = floor(vec2(screenUv.x * gridX, screenUv.y * gridY));
            float s = 0.0;
            for (int yi = -1; yi <= 1; yi++) {
              for (int xi = -1; xi <= 1; xi++) {
                vec2 cell = baseCell + vec2(float(xi), float(yi));
                if (cell.y < 0.0 || cell.y >= gridY) continue;
                cell.x = mod(cell.x + gridX, gridX);
                s += star(screenUv, cell, grid);
              }
            }
            float horizonFade = smoothstep(0.35, 0.55, screenUv.y);
            vec3 starColor = vec3(1.0, 0.97, 0.9);
            color += starColor * s * horizonFade;
          }

          vec3 moonDir = normalize(vec3(0.4, 0.39, 0.9));
          vec2 moonScreenUv = dirToScreenUV(moonDir);
          if (moonScreenUv.x >= 0.0 && moonScreenUv.x <= 1.0 && moonScreenUv.y >= 0.0 && moonScreenUv.y <= 1.0) {
            vec2 moonDeltaPx = (screenUv - moonScreenUv) * iResolution.xy;
            float moonRadiusPx = min(iResolution.x, iResolution.y) * 0.0294;
            float dist = length(moonDeltaPx);
            float moonEdge = smoothstep(moonRadiusPx, moonRadiusPx * 0.8, dist);
            if (moonEdge > 0.0) {
              vec2 moonUv = moonDeltaPx / moonRadiusPx;
              float limb = smoothstep(1.0, 0.45, length(moonUv));
              float crater = fbm(moonUv * 7.0) + 0.5 * fbm(moonUv * 16.0);
              crater = smoothstep(0.3, 0.85, crater);
              vec3 moonNormal = normalize(vec3(moonUv, sqrt(max(0.0, 1.0 - dot(moonUv, moonUv)))));
              vec3 moonLightDir = normalize(vec3(0.2, 0.25, 0.9));
              float moonLight = clamp(dot(moonNormal, moonLightDir), 0.0, 1.0);
              vec3 moonColor = vec3(1.2, 1.15, 1.05) * (0.7 + 0.5 * moonLight) * 0.6;
              moonColor *= mix(1.0, 0.6, crater);
              moonColor *= limb;
              color += moonColor * moonEdge;
            }
          }
        }

        color += vec3(1.0) * skyLight * 1.4 * u_ambientIntensity;
        return color;
      }

      float sampleLogo(vec2 uv) {
        vec2 local = (uv - u_logoCenter) / u_logoSize + 0.5;
        float inside = step(0.0, local.x) * step(local.x, 1.0) * step(0.0, local.y) * step(local.y, 1.0);
        float alpha = texture2D(u_logo, local).a * inside;
        return alpha * u_logoFade;
      }

      vec3 aces_tonemap(vec3 color) {  
        mat3 m1 = mat3(
          0.59719, 0.07600, 0.02840,
          0.35458, 0.90834, 0.13383,
          0.04823, 0.01566, 0.83777
        );
        mat3 m2 = mat3(
          1.60475, -0.10208, -0.00327,
          -0.53108,  1.10813, -0.07276,
          -0.07367, -0.00605,  1.07602
        );
        vec3 v = m1 * color;  
        vec3 a = v * (v + 0.0245786) - 0.000090537;
        vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;
        return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  
      }

      void mainImage(out vec4 fragColor, in vec2 fragCoord) {
        vec3 ray = getRay(fragCoord);
        if(ray.y >= 0.0) {
          float skyLight = texture2D(u_light, skyUV(ray)).r;
          vec3 daySky = getDaySky(ray, skyLight);
          vec3 nightSky = getNightSky(ray, skyLight);
          vec3 C = mix(daySky, nightSky, u_night);
          fragColor = vec4(aces_tonemap(C * 2.0), 1.0);   
          return;
        }

        vec3 waterPlaneHigh = vec3(0.0, 0.0, 0.0);
        vec3 waterPlaneLow = vec3(0.0, -WATER_DEPTH, 0.0);
        vec3 origin = vec3(iTime * 0.2, CAMERA_HEIGHT, 1);

        float highPlaneHit = intersectPlane(origin, ray, waterPlaneHigh, vec3(0.0, 1.0, 0.0));
        float lowPlaneHit = intersectPlane(origin, ray, waterPlaneLow, vec3(0.0, 1.0, 0.0));
        vec3 highHitPos = origin + ray * highPlaneHit;
        vec3 lowHitPos = origin + ray * lowPlaneHit;

        float dist = raymarchwater(origin, highHitPos, lowHitPos, WATER_DEPTH);
        vec3 waterHitPos = origin + ray * dist;

        vec3 N = normal(waterHitPos.xz, 0.01, WATER_DEPTH);
        N = mix(N, vec3(0.0, 1.0, 0.0), 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));

        float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));

        vec3 R = normalize(reflect(ray, N));
        R.y = abs(R.y);
        
        float reflectedLight = texture2D(u_light, skyUV(R)).r;
        float reflectedLogo = sampleLogo(skyUV(R));
        vec3 dayReflection = getDaySky(R, reflectedLight);
        vec3 nightReflection = getNightSky(R, reflectedLight);
        vec3 reflection = mix(dayReflection, nightReflection, u_night) + vec3(1.0) * (reflectedLogo * LOGO_INTENSITY);
        vec3 scatteringBase = mix(vec3(0.08, 0.08, 0.09), vec3(0.02, 0.02, 0.03), u_night);
        vec3 scattering = scatteringBase * (0.2 + (waterHitPos.y + WATER_DEPTH) / WATER_DEPTH);

        vec3 C = fresnel * reflection + scattering;
        
        // Add distance fog
        vec3 fogColor = mix(vec3(0.55, 0.55, 0.58), vec3(0.03, 0.035, 0.05), u_night);
        float fogAmount = 1.0 - exp(-dist * 0.02);
        C = mix(C, fogColor, fogAmount);
        
        fragColor = vec4(aces_tonemap(C * 2.0), 1.0);
      }

      void main() {
        mainImage(gl_FragColor, gl_FragCoord.xy);
      }
    `;
    }

    let fragmentShaderSource = buildFragmentShader(currentQuality);

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(gl, vertexShader, fragmentShader) {
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    // Ocean wave program
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    let oceanFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    let program = createProgram(gl, vertexShader, oceanFragmentShader);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1, 1, -1, -1, 1,
      -1, 1, 1, -1, 1, 1
    ]), gl.STATIC_DRAW);

    let positionLocation = gl.getAttribLocation(program, 'position');
    let resolutionLocation = gl.getUniformLocation(program, 'iResolution');
    let timeLocation = gl.getUniformLocation(program, 'iTime');
    let lightTextureLocation = gl.getUniformLocation(program, 'u_light');
    let logoTextureLocation = gl.getUniformLocation(program, 'u_logo');
    let logoCenterLocation = gl.getUniformLocation(program, 'u_logoCenter');
    let logoSizeLocation = gl.getUniformLocation(program, 'u_logoSize');
    let logoFadeLocation = gl.getUniformLocation(program, 'u_logoFade');
    let ripplesLocation = gl.getUniformLocation(program, 'u_ripples');
    let rippleCountLocation = gl.getUniformLocation(program, 'u_rippleCount');
    let nightLocation = gl.getUniformLocation(program, 'u_night');
    let ambientLocation = gl.getUniformLocation(program, 'u_ambientIntensity');

    function rebuildOceanProgram() {
      fragmentShaderSource = buildFragmentShader(currentQuality);
      if (oceanFragmentShader) gl.deleteShader(oceanFragmentShader);
      if (program) gl.deleteProgram(program);
      
      oceanFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
      program = createProgram(gl, vertexShader, oceanFragmentShader);
      
      positionLocation = gl.getAttribLocation(program, 'position');
      resolutionLocation = gl.getUniformLocation(program, 'iResolution');
      timeLocation = gl.getUniformLocation(program, 'iTime');
      lightTextureLocation = gl.getUniformLocation(program, 'u_light');
      logoTextureLocation = gl.getUniformLocation(program, 'u_logo');
      logoCenterLocation = gl.getUniformLocation(program, 'u_logoCenter');
      logoSizeLocation = gl.getUniformLocation(program, 'u_logoSize');
      logoFadeLocation = gl.getUniformLocation(program, 'u_logoFade');
      ripplesLocation = gl.getUniformLocation(program, 'u_ripples');
      rippleCountLocation = gl.getUniformLocation(program, 'u_rippleCount');
      nightLocation = gl.getUniformLocation(program, 'u_night');
      ambientLocation = gl.getUniformLocation(program, 'u_ambientIntensity');
    }

    function setQuality(quality) {
      if (!QUALITY_LEVELS.includes(quality) || quality === currentQuality) return;
      currentQuality = quality;
      rebuildOceanProgram();
      resize();
      lastQualityChangeTime = performance.now();
    }

    function updateAutoQuality(time, fps) {
      // Add FPS sample with timestamp
      autoQualityFpsHistory.push({ time, fps });

      // Remove old samples outside the window
      const cutoff = time - AUTO_QUALITY_SAMPLE_TIME;
      while (autoQualityFpsHistory.length > 0 && autoQualityFpsHistory[0].time < cutoff) {
        autoQualityFpsHistory.shift();
      }

      // Need enough samples before making decisions
      if (autoQualityFpsHistory.length < 3) return;

      // Check cooldown
      if (time - lastQualityChangeTime < AUTO_QUALITY_COOLDOWN) return;

      // Calculate average FPS
      const avgFps = autoQualityFpsHistory.reduce((sum, s) => sum + s.fps, 0) / autoQualityFpsHistory.length;
      const currentIndex = QUALITY_LEVELS.indexOf(currentQuality);

      if (avgFps < AUTO_QUALITY_FPS_LOW && currentIndex > 0) {
        // FPS too low, reduce quality
        setQuality(QUALITY_LEVELS[currentIndex - 1]);
        autoQualityFpsHistory = []; // Reset history after change
      } else if (avgFps > AUTO_QUALITY_FPS_HIGH && currentIndex < QUALITY_LEVELS.length - 1) {
        // FPS high enough, try increasing quality
        setQuality(QUALITY_LEVELS[currentIndex + 1]);
        autoQualityFpsHistory = []; // Reset history after change
      }
    }

    // Dither post-process program
    const ditherVertexShader = createShader(gl, gl.VERTEX_SHADER, ditherVertexShaderSource);
    const ditherFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, ditherFragmentShaderSource);
    const ditherProgram = createProgram(gl, ditherVertexShader, ditherFragmentShader);

    const lightDecayFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, lightDecayFragmentShaderSource);
    const lightDecayProgram = createProgram(gl, ditherVertexShader, lightDecayFragmentShader);

    const lightPointVertexShader = createShader(gl, gl.VERTEX_SHADER, lightPointVertexShaderSource);
    const lightPointFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, lightPointFragmentShaderSource);
    const lightPointProgram = createProgram(gl, lightPointVertexShader, lightPointFragmentShader);

    const ditherPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ditherPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);
    const ditherPositionLocation = gl.getAttribLocation(ditherProgram, 'a_position');
    const lightDecayPositionLocation = gl.getAttribLocation(lightDecayProgram, 'a_position');

    const ditherTexCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ditherTexCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 0,1, 1,1]), gl.STATIC_DRAW);
    const ditherTexCoordLocation = gl.getAttribLocation(ditherProgram, 'a_texCoord');
    const lightDecayTexCoordLocation = gl.getAttribLocation(lightDecayProgram, 'a_texCoord');

    const ditherResolutionLocation = gl.getUniformLocation(ditherProgram, 'u_resolution');
    const ditherImageLocation = gl.getUniformLocation(ditherProgram, 'u_image');
    const ditherTimeLocation = gl.getUniformLocation(ditherProgram, 'u_time');
    const ditherNightLocation = gl.getUniformLocation(ditherProgram, 'u_night');

    const lightDecayImageLocation = gl.getUniformLocation(lightDecayProgram, 'u_light');
    const lightDecayFactorLocation = gl.getUniformLocation(lightDecayProgram, 'u_decay');
    const lightDecayCutoffLocation = gl.getUniformLocation(lightDecayProgram, 'u_cutoff');

    const lightPointPositionLocation = gl.getAttribLocation(lightPointProgram, 'a_position');
    const lightPointUvDerivLocation = gl.getAttribLocation(lightPointProgram, 'a_uvDeriv');
    const lightPointScreenRadiusLocation = gl.getAttribLocation(lightPointProgram, 'a_screenRadius');
    const lightPointTexSizeLocation = gl.getUniformLocation(lightPointProgram, 'u_texSize');
    const lightPointBuffer = gl.createBuffer();

    // Framebuffer for render-to-texture
    let framebuffer = null;
    let renderTexture = null;
    let fbWidth = 0;
    let fbHeight = 0;

    let lightFramebuffers = [null, null];
    let lightTextures = [null, null];
    let lightWriteIndex = 0;
    let lastLightTime = 0;

    const logoCenter = [0.53, 0.72];
    let logoSize = [0.18, 0.18 / 1.32];
    let logoFadeStart = null;
    const logoTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, logoTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 0]));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    function setupFramebuffer(width, height) {
      if (framebuffer && fbWidth === width && fbHeight === height) return;
      
      if (framebuffer) {
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(renderTexture);
      }

      fbWidth = width;
      fbHeight = height;

      renderTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, renderTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    function createLightTexture(width, height) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      return texture;
    }

    function setupLightFramebuffers(width, height) {
      for (let i = 0; i < 2; i++) {
        if (lightFramebuffers[i]) {
          gl.deleteFramebuffer(lightFramebuffers[i]);
          gl.deleteTexture(lightTextures[i]);
        }
        lightTextures[i] = createLightTexture(width, height);
        lightFramebuffers[i] = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, lightFramebuffers[i]);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, lightTextures[i], 0);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      lightWriteIndex = 0;
    }

    function setupLogoTexture() {
      const svg = document.querySelector('#logo svg');
      if (!svg) return;

      let logoAspect = 1.32;
      const viewBox = svg.getAttribute('viewBox');
      if (viewBox) {
        const parts = viewBox.trim().split(/\s+/).map(Number);
        if (parts.length === 4 && parts[2] > 0 && parts[3] > 0) {
          logoAspect = parts[2] / parts[3];
        }
      }
      const baseSize = 0.18;
      logoSize = [baseSize, baseSize / logoAspect];

      const svgData = new XMLSerializer().serializeToString(svg);
      const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const img = new Image();

      img.onload = () => {
        const width = 512;
        const height = Math.max(1, Math.round(width / logoAspect));
        const logoCanvas = document.createElement('canvas');
        logoCanvas.width = width;
        logoCanvas.height = height;
        const ctx = logoCanvas.getContext('2d');
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(img, 0, 0, width, height);
        gl.bindTexture(gl.TEXTURE_2D, logoTexture);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, logoCanvas);
        URL.revokeObjectURL(url);
      };

      img.onerror = () => {
        URL.revokeObjectURL(url);
      };

      img.src = url;
    }

    function getViewportSize() {
      if (window.visualViewport) {
        return {
          width: window.visualViewport.width,
          height: window.visualViewport.height
        };
      }
      return {
        width: window.innerWidth,
        height: window.innerHeight
      };
    }

    function resize() {
      const { width, height } = getViewportSize();
      // Render at reduced resolution based on quality setting
      const scale = QUALITY_SETTINGS[currentQuality].scale;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
      canvas.width = width * window.devicePixelRatio * scale;
      canvas.height = height * window.devicePixelRatio * scale;
      setupFramebuffer(canvas.width, canvas.height);
      setupLightFramebuffers(canvas.width, canvas.height);
      updateLogoPlacement();
    }

    window.addEventListener('resize', resize);
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', resize);
    }
    resize();
    setupLogoTexture();
    updateLogoPlacement();

    // FPS tracking
    let frameCount = 0;
    let lastFpsUpdate = 0;

    const pendingLightPoints = [];
    let isDrawing = false;

    // Ripple system
    const MAX_RIPPLES = 10;
    const ripples = []; // Array of {x, z, time, amplitude}
    
    function screenToWaterHit(clientX, clientY, time) {
      const rect = canvas.getBoundingClientRect();
      const ndcX = (clientX - rect.left) / rect.width * 2 - 1;
      const ndcY = -((clientY - rect.top) / rect.height * 2 - 1);
      
      const aspect = canvas.width / canvas.height;
      let rayX = ndcX * aspect;
      let rayY = ndcY;
      let rayZ = 1.5;
      const len = Math.hypot(rayX, rayY, rayZ);
      rayX /= len; rayY /= len; rayZ /= len;
      
      // Apply camera tilt (-0.05 radians around X axis)
      const cosTilt = Math.cos(-0.05);
      const sinTilt = Math.sin(-0.05);
      const newY = rayY * cosTilt - rayZ * sinTilt;
      const newZ = rayY * sinTilt + rayZ * cosTilt;
      rayY = newY;
      rayZ = newZ;
      
      // Camera position (matches shader)
      const camX = time * 0.2;
      const camY = 1.5; // CAMERA_HEIGHT
      const camZ = 1.0;
      
      // Intersect with y=0 plane
      if (rayY >= 0) return null; // Looking up, no water hit
      
      const t = -camY / rayY;
      return { x: camX + rayX * t, z: camZ + rayZ * t };
    }
    
    function addRipple(worldX, worldZ, time, amplitude = 0.15) {
      ripples.push({ x: worldX, z: worldZ, time: time, amplitude: amplitude });
      if (ripples.length > MAX_RIPPLES) {
        ripples.shift();
      }
    }
    
    function getRippleUniforms() {
      const data = new Float32Array(MAX_RIPPLES * 4);
      for (let i = 0; i < ripples.length; i++) {
        const r = ripples[i];
        data[i * 4 + 0] = r.x;
        data[i * 4 + 1] = r.z;
        data[i * 4 + 2] = r.time;
        data[i * 4 + 3] = r.amplitude;
      }
      return data;
    }

    function wrapUVDelta(a, b) {
      let d = a - b;
      if (d > 0.5) d -= 1.0;
      if (d < -0.5) d += 1.0;
      return d;
    }

    function screenPosToSkyUV(screenX, screenY, aspect) {
      const uvX = screenX * 2 - 1;
      const uvY = screenY * 2 - 1;
      const projX = uvX * aspect;
      const projY = uvY;
      const projZ = 1.5;

      const projLen = Math.hypot(projX, projY, projZ);
      let rayX = projX / projLen;
      let rayY = projY / projLen;
      let rayZ = projZ / projLen;

      const cosTilt = Math.cos(-0.05);
      const sinTilt = Math.sin(-0.05);
      const rotatedY = rayY * cosTilt + rayZ * sinTilt;
      const rotatedZ = -rayY * sinTilt + rayZ * cosTilt;
      rayY = rotatedY;
      rayZ = rotatedZ;

      if (rayY < 0) return null;

      const u = ((Math.atan2(rayZ, rayX) / (2 * Math.PI)) + 0.5) % 1;
      const v = Math.min(1, Math.max(0, rayY * 0.5 + 0.5));
      return { u, v };
    }

    function screenToSkyUV(event) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const xPx = (event.clientX - rect.left) * scaleX;
      const yPx = (rect.height - (event.clientY - rect.top)) * scaleY;
      const x = xPx / canvas.width;
      const y = yPx / canvas.height;
      if (x < 0 || x > 1 || y < 0 || y > 1) return null;

      const aspect = canvas.width / canvas.height;
      const result = screenPosToSkyUV(x, y, aspect);
      if (!result) return null;

      // Compute Jacobian: how much u and v change per device pixel
      const epsPx = 1;
      const rightX = (xPx + epsPx) / canvas.width;
      const leftX = (xPx - epsPx) / canvas.width;
      const upY = (yPx + epsPx) / canvas.height;
      const downY = (yPx - epsPx) / canvas.height;
      const uvRight = screenPosToSkyUV(rightX, y, aspect);
      const uvLeft = screenPosToSkyUV(leftX, y, aspect);
      const uvUp = screenPosToSkyUV(x, upY, aspect);
      const uvDown = screenPosToSkyUV(x, downY, aspect);

      let du_dx = 0.001;
      let dv_dx = 0.0;
      let du_dy = 0.0;
      let dv_dy = 0.001;

      if (uvRight && uvLeft) {
        du_dx = wrapUVDelta(uvRight.u, uvLeft.u) / (2 * epsPx);
        dv_dx = (uvRight.v - uvLeft.v) / (2 * epsPx);
      } else if (uvRight) {
        du_dx = wrapUVDelta(uvRight.u, result.u) / epsPx;
        dv_dx = (uvRight.v - result.v) / epsPx;
      } else if (uvLeft) {
        du_dx = wrapUVDelta(result.u, uvLeft.u) / epsPx;
        dv_dx = (result.v - uvLeft.v) / epsPx;
      }

      if (uvUp && uvDown) {
        du_dy = wrapUVDelta(uvUp.u, uvDown.u) / (2 * epsPx);
        dv_dy = (uvUp.v - uvDown.v) / (2 * epsPx);
      } else if (uvUp) {
        du_dy = wrapUVDelta(uvUp.u, result.u) / epsPx;
        dv_dy = (uvUp.v - result.v) / epsPx;
      } else if (uvDown) {
        du_dy = wrapUVDelta(result.u, uvDown.u) / epsPx;
        dv_dy = (result.v - uvDown.v) / epsPx;
      }

      return { u: result.u, v: result.v, du_dx, dv_dx, du_dy, dv_dy };
    }

    function updateLogoPlacement() {
      if (!logo) return;
      const canvasRect = canvas.getBoundingClientRect();
      const logoRect = logo.getBoundingClientRect();
      if (!canvasRect.width || !canvasRect.height) return;

      const centerX = (logoRect.left + logoRect.width / 2 - canvasRect.left) / canvasRect.width;
      const centerY = 1 - (logoRect.top + logoRect.height / 2 - canvasRect.top) / canvasRect.height;
      const aspect = canvas.width / canvas.height;
      const centerUV = screenPosToSkyUV(centerX, centerY, aspect);
      if (!centerUV) return;

      const halfWidth = (logoRect.width / 2) / canvasRect.width;
      const halfHeight = (logoRect.height / 2) / canvasRect.height;
      const leftUV = screenPosToSkyUV(centerX - halfWidth, centerY, aspect);
      const rightUV = screenPosToSkyUV(centerX + halfWidth, centerY, aspect);
      const upUV = screenPosToSkyUV(centerX, centerY + halfHeight, aspect);
      const downUV = screenPosToSkyUV(centerX, centerY - halfHeight, aspect);

      let sizeU = logoSize[0];
      let sizeV = logoSize[1];

      if (leftUV && rightUV) {
        sizeU = Math.abs(wrapUVDelta(rightUV.u, leftUV.u));
      }
      if (upUV && downUV) {
        sizeV = Math.abs(upUV.v - downUV.v);
      }

      logoCenter[0] = centerUV.u;
      logoCenter[1] = centerUV.v;
      logoSize[0] = sizeU;
      logoSize[1] = sizeV;
    }

    function queueLightPoints(event) {
      const skyUV = screenToSkyUV(event);
      if (!skyUV) return;

      const sprinkleCount = 10;
      for (let i = 0; i < sprinkleCount; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = (Math.random() * 10 + 6) * window.devicePixelRatio;
        const offsetX = Math.cos(angle) * radius;
        const offsetY = Math.sin(angle) * radius;

        const jitterU = skyUV.du_dx * offsetX + skyUV.du_dy * offsetY;
        const jitterV = skyUV.dv_dx * offsetX + skyUV.dv_dy * offsetY;

        // Radius in screen pixels (independent of resolution)
        const screenRadius = (Math.random() * 6 + 4) * window.devicePixelRatio;
        const px = (skyUV.u + jitterU + 1) % 1;
        const py = Math.min(1, Math.max(0, skyUV.v + jitterV));
        // 7 floats per point: x, y, du_dx, dv_dx, du_dy, dv_dy, screenRadius
        pendingLightPoints.push(px, py, skyUV.du_dx, skyUV.dv_dx, skyUV.du_dy, skyUV.dv_dy, screenRadius);
      }

      if (pendingLightPoints.length > 4200) {
        pendingLightPoints.splice(0, pendingLightPoints.length - 4200);
      }
    }

    canvas.addEventListener('pointerdown', (event) => {
      isDrawing = true;
      queueLightPoints(event);
    });

    canvas.addEventListener('pointermove', (event) => {
      if (isDrawing) {
        queueLightPoints(event);
      }
    });

    window.addEventListener('pointerup', () => {
      isDrawing = false;
    });

    // Ripple on click
    canvas.addEventListener('click', (e) => {
      const time = performance.now() * 0.001;
      const hit = screenToWaterHit(e.clientX, e.clientY, time);
      if (hit) {
        addRipple(hit.x, hit.z, time, 0.08);
      }
    });

    function updateLightTexture(time) {
      if (!lastLightTime) {
        lastLightTime = time;
      }
      const delta = Math.max(0, (time - lastLightTime) * 0.001);
      lastLightTime = time;
      const fadeDuration = 240;
      const targetIntensity = LIGHT_INTENSITY;
      const decayCutoff = 1 / 255;
      const decayFloor = (1 / 255) / targetIntensity;
      const decay = Math.pow(decayFloor, delta / fadeDuration);
      const readIndex = lightWriteIndex;
      const writeIndex = 1 - lightWriteIndex;

      gl.bindFramebuffer(gl.FRAMEBUFFER, lightFramebuffers[writeIndex]);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.useProgram(lightDecayProgram);

      gl.enableVertexAttribArray(lightDecayPositionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherPositionBuffer);
      gl.vertexAttribPointer(lightDecayPositionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(lightDecayTexCoordLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherTexCoordBuffer);
      gl.vertexAttribPointer(lightDecayTexCoordLocation, 2, gl.FLOAT, false, 0, 0);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, lightTextures[readIndex]);
      gl.uniform1i(lightDecayImageLocation, 0);
      gl.uniform1f(lightDecayFactorLocation, decay);
      gl.uniform1f(lightDecayCutoffLocation, decayCutoff);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      if (pendingLightPoints.length > 0) {
        gl.useProgram(lightPointProgram);
        gl.uniform2f(lightPointTexSizeLocation, canvas.width, canvas.height);
        gl.bindBuffer(gl.ARRAY_BUFFER, lightPointBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pendingLightPoints), gl.DYNAMIC_DRAW);

        // 7 floats per vertex: x, y, du_dx, dv_dx, du_dy, dv_dy, screenRadius (28 bytes)
        gl.enableVertexAttribArray(lightPointPositionLocation);
        gl.vertexAttribPointer(lightPointPositionLocation, 2, gl.FLOAT, false, 28, 0);

        gl.enableVertexAttribArray(lightPointUvDerivLocation);
        gl.vertexAttribPointer(lightPointUvDerivLocation, 4, gl.FLOAT, false, 28, 8);

        gl.enableVertexAttribArray(lightPointScreenRadiusLocation);
        gl.vertexAttribPointer(lightPointScreenRadiusLocation, 1, gl.FLOAT, false, 28, 24);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE);
        gl.drawArrays(gl.POINTS, 0, pendingLightPoints.length / 7);
        gl.disable(gl.BLEND);

        pendingLightPoints.length = 0;
      }

      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      lightWriteIndex = writeIndex;
    }

    function render(time) {
      // Update FPS counter
      frameCount++;
      if (time - lastFpsUpdate >= 1000) {
        const fps = frameCount;
        fpsDisplay.textContent = `FPS: ${fps} | ${canvas.width}x${canvas.height} | Quality: ${currentQuality}`;
        
        // Update auto quality based on measured FPS
        updateAutoQuality(time, fps);
        
        frameCount = 0;
        lastFpsUpdate = time;
      }

      updateLightTexture(time);

      if (logoFadeStart === null) {
        logoFadeStart = time + LOGO_FADE_DELAY;
      }
      const logoProgress = Math.min(Math.max((time - logoFadeStart) / LOGO_FADE_DURATION, 0), 1);
      const logoFade = logoProgress * LOGO_FADE_TARGET;

      // Pass 1: Render ocean waves to framebuffer
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.useProgram(program);
      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(timeLocation, time * 0.001);
      gl.uniform2f(logoCenterLocation, logoCenter[0], logoCenter[1]);
      gl.uniform2f(logoSizeLocation, logoSize[0], logoSize[1]);
      gl.uniform1f(logoFadeLocation, logoFade);
      const nightValue = getNightPreference() ? 1.0 : 0.0;
      gl.uniform1f(nightLocation, nightValue);
      gl.uniform1f(ambientLocation, getNightPreference() ? 0.28 : 1.0);
      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, lightTextures[lightWriteIndex]);
      gl.uniform1i(lightTextureLocation, 1);
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, logoTexture);
      gl.uniform1i(logoTextureLocation, 2);
      
      // Pass ripple uniforms
      gl.uniform4fv(ripplesLocation, getRippleUniforms());
      gl.uniform1i(rippleCountLocation, ripples.length);
      
      gl.drawArrays(gl.TRIANGLES, 0, 6);

      // Pass 2: Apply dither post-processing to screen
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.useProgram(ditherProgram);

      gl.enableVertexAttribArray(ditherPositionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherPositionBuffer);
      gl.vertexAttribPointer(ditherPositionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.enableVertexAttribArray(ditherTexCoordLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, ditherTexCoordBuffer);
      gl.vertexAttribPointer(ditherTexCoordLocation, 2, gl.FLOAT, false, 0, 0);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, renderTexture);
      gl.uniform1i(ditherImageLocation, 0);
      gl.uniform2f(ditherResolutionLocation, canvas.width, canvas.height);
      gl.uniform1f(ditherTimeLocation, time * 0.001);
      gl.uniform1f(ditherNightLocation, nightValue);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // Logo fade-in animation
    setTimeout(() => {
      logo.style.transition = `opacity ${LOGO_FADE_DURATION / 1000}s ease`;
      logo.style.opacity = `${LOGO_FADE_TARGET}`;
    }, LOGO_FADE_DELAY);
  </script>
</body>
</html>
